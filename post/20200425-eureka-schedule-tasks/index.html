<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>从定时任务分析 Eureka 架构设计 - ZengXu&#39;s BLOG</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Zeng Xu" /><meta name="description" content="扒一扒 Eureka 中的定时任务" /><meta name="keywords" content="Spring Cloud, Eureka, Spring, Java" />






<meta name="generator" content="Hugo 0.60.1 with theme even" />


<link rel="canonical" href="https://www.zeng.dev/post/20200425-eureka-schedule-tasks/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.3eede659.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="从定时任务分析 Eureka 架构设计" />
<meta property="og:description" content="扒一扒 Eureka 中的定时任务" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.zeng.dev/post/20200425-eureka-schedule-tasks/" />
<meta property="article:published_time" content="2020-04-25T20:40:29+08:00" />
<meta property="article:modified_time" content="2020-05-08T00:22:00+08:00" />
<meta itemprop="name" content="从定时任务分析 Eureka 架构设计">
<meta itemprop="description" content="扒一扒 Eureka 中的定时任务">
<meta itemprop="datePublished" content="2020-04-25T20:40:29&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-08T00:22:00&#43;08:00" />
<meta itemprop="wordCount" content="5007">



<meta itemprop="keywords" content="Spring Cloud,Eureka,Spring,Java," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从定时任务分析 Eureka 架构设计"/>
<meta name="twitter:description" content="扒一扒 Eureka 中的定时任务"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Zeng Xu&#39;s BLOG</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Zeng Xu&#39;s BLOG</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">从定时任务分析 Eureka 架构设计</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-04-25 20:40 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#heading">写在前面</a></li>
    <li><a href="#lets-go">let's go</a></li>
    <li><a href="#server">Server</a>
      <ul>
        <li><a href="#cachefilltimer">CacheFillTimer</a></li>
        <li><a href="#deltaretentiontimer">DeltaRetentionTimer</a></li>
        <li><a href="#taskacceptor--taskbatchingworker">TaskAcceptor & TaskBatchingWorker</a></li>
        <li><a href="#taskacceptor--tasknonbatchingworker">TaskAcceptor & TaskNonBatchingWorker</a></li>
        <li><a href="#evict-">Evict 任务</a></li>
        <li><a href="#peernodesupdater">PeerNodesUpdater</a></li>
        <li><a href="#measureratetimer--numberofreplicationslastmin">MeasureRateTimer → numberOfReplicationsLastMin</a></li>
      </ul>
    </li>
    <li><a href="#client">Client</a>
      <ul>
        <li><a href="#cacherefresh">CacheRefresh</a></li>
        <li><a href="#heartbeat">heartbeat</a></li>
        <li><a href="#instanceinforeplicator">InstanceInfoReplicator</a></li>
        <li><a href="#asyncresolverbootstrap0">AsyncResolver-bootstrap-0</a></li>
      </ul>
    </li>
    <li><a href="#transport">Transport</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="heading">写在前面</h2>
<p>Eureka 功能是服务注册发现，核心实现在 package com.netflix.eureka.registry，其他几万行代码都绕着这 2000 来行代码展开。</p>
<p>接口 LookupService 声明了服务发现功能，接口 LeaseManager 声明租期管理功能，接口 InstanceRegistry 继承前两者并额外声明了实例信息覆盖、实例列表增量获取、响应缓存、自我保护等功能。最高抽象类 AbstractInstanceRegistry 实现了 InstanceRegistry，实际上就是在一个 ConcurrentHashMap 中维护注册信息，然后围绕该 Map 处理服务发现、服务注册、服务续租、服务下线、服务淘汰。</p>
<p>接口 PeerAwareInstanceRegistry 在 InstanceRegistry 之上提供 Eureka 集群实例之间的信息同步功能，而 PeerAwareInstanceRegistryImpl 继承抽象 AbstractInstanceRegistry 并实现了 PeerAwareInstanceRegistry 接口，所以 Eureka 中使用的实现类为 PeerAwareInstanceRegistryImpl。</p>
<img src="/img/2020-04/eureka-regsitry-class.jpg" width="500px">
<p>在 registry 包基础上，Eureka 为实现高并发低延迟、配置动态更新、故障自动检测和监控等目标，大量使用了缓存、异步、批处理等技术，而这些在实现时多依赖定时任务。所以顺着定时任务扒，很容易弄懂 Eureka 的设计架构和高性能原理。</p>
<p>Eureka 在架构上主要围绕以下几点方面做文章：</p>
<ol>
<li>围绕 Get 类请求，如获取应用列表和详情，Eureka 支持增量（delta） 获取，同时设置 2 级服务端缓存和客户端缓存，大幅度减少了核心 Registry 的并发度，带来了更少的带宽消耗和更低的延迟。</li>
<li>针对集群 Peer replication，每个 Peer Node 启用独立异步线程组，其一是异步处理，快速响应客户端请求，其二是实例信息批量同步，可以有效提高吞吐；最后则是使用舱壁模式隔离 Peer Node，这样即使某个 Peer Node 出现响应过慢或者无响应，并不会因线程耗尽而影响其他 Peer Node 接收信息同步。</li>
<li>围绕定时淘汰未续租过期实例功能，设计实现了灵活可配置的自我保护模式，可以解决网络分区问题，提高集群可用性</li>
</ol>
<img src="/img/2020-04/eureka-draft.jpg" width="500px">
<h2 id="lets-go">let's go</h2>
<p>启动 Eureka server，将其注册到某个集群，启动后，可通过 jstack <pid> 得到如下线程列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-text" data-lang="text">// Eureka Server 任务线程
Eureka-CacheFillTimer
Eureka-DeltaRetentionTimer
Eureka-EvictionTimer
ReplicaAwareInstanceRegistry - RenewalThresholdUpdater
Eureka-MeasureRateTime
--- Peers ---
Eureka-PeerNodesUpdater
TaskAcceptor-peer1,TaskNonBatchingWorker-peer1-0 // AWS ASG
TaskAcceptor-peer2,TaskNonBatchingWorker-peer2-0 // AWS ASG
TaskAcceptor-target_peer1
TaskBatchingWorker-target_peer1-0
... 省略 1-18
TaskBatchingWorker-target_peer1-19
TaskAcceptor-target_peer2
TaskBatchingWorker-target_peer2-0
... 省略 1-18
TaskBatchingWorker-target_peer2-19

// Eureka Client 任务线程
DiscoveryClient-0
DiscoveryClient-1
DiscoveryClient-InstanceInfoReplicator-0
DiscoveryClient-HeartbeatExecutor-0
DiscoveryClient-CacheRefreshExecutor-0
AsyncResolver-bootstrap-0

// Eureka HTTP Transport 任务线程
Eureka-JerseyClient-Conn-Cleaner
</code></pre></td></tr></table>
</div>
</div><h2 id="server">Server</h2>
<p>以下定时任务处理 Get 请求 2 级缓存和增量 delta 队列</p>
<ul>
<li>Eureka-CacheFillTimer</li>
<li>Eureka-DeltaRetentionTimer</li>
</ul>
<p>以下定时任务处理 Peer Replication</p>
<ul>
<li>TaskAcceptor-target_peer*</li>
<li>TaskBatchingWorker-target_peer*-0 至 TaskBatchingWorker-target_peer*-19</li>
<li>TaskAcceptor-peer*,TaskNonBatchingWorker-peer*-0</li>
</ul>
<p>以下定时任务处理过期实例淘汰及自我保护</p>
<ul>
<li>Eureka-EvictionTimer</li>
<li>ReplicaAwareInstanceRegistry - RenewalThresholdUpdater</li>
<li>Eureka-MeasureRateTime</li>
</ul>
<p>注：以下标题中的 task 名均省去了 <code>Eureka-</code> 前缀 (如果有) 。</p>
<h3 id="cachefilltimer">CacheFillTimer</h3>
<p>CacheFillTimer 定时任务的作用就是每 30s 从 readWriteCache 同步一次实例信息至 readOnlyCache，
实现细节见 com.netflix.eureka.registry.ResponseCacheImpl。
<img src="/img/2020-04/eureka-response-cache.jpg" width="700px"></p>
<div class='align-center'>
<p>请求——2 级响应缓存——Registry 流转逻辑</p>
</div>
<p>默认情况下 Eureka， 开启使用 2 级缓存提高实例获取性能，只有当 2 层缓存均不存在实例信息时，才会从 InstanceRegistry 获取注册信息，路径 /{version}/apps/ 下的 GET 请求均会被缓存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 使用 java.util.Timer 定时执行
</span><span class="c1"></span><span class="c1">// 每 30s 从 readWriteCacheMap 同步
</span><span class="c1"></span><span class="k">if</span> <span class="o">(</span><span class="n">shouldUseReadOnlyResponseCache</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">timer</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="n">getCacheUpdateTask</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
          <span class="k">new</span> <span class="n">Date</span><span class="o">(</span><span class="o">(</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(</span><span class="o">)</span> <span class="o">/</span> <span class="n">responseCacheUpdateIntervalMs</span><span class="o">)</span> <span class="o">*</span> <span class="n">responseCacheUpdateIntervalMs</span><span class="o">)</span>
                  <span class="o">+</span> <span class="n">responseCacheUpdateIntervalMs</span><span class="o">)</span><span class="o">,</span>
          <span class="n">responseCacheUpdateIntervalMs</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>根据 2 级响应缓存时效，结合后文会提到的客户端缓存时长 30s，可以量化 Eureka 的弱一致性。</p>
<p>假设某个实例在退出前取消注册，server 会 invalidate readWriteCache，因此最长存在 60s(readOnlyCache 30s + clientCache 30s) 延迟；假设某个实例在发送完 heart-beat 后立刻退出且没取消注册，那么可能存在 120s 延迟(readOnlyCache 30s + evict every 60s + clientCache 30s)。即使禁用 readOnlyCache，最大也会存在 90s 延迟。</p>
<p>该定时任务对应配置如下，readOnlyCache 可以通过 <code>eureka.server.use-read-only-response-cache</code> 禁用（CacheFillTimer定时任务也随之被禁用），readwriteCache 无法被禁用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>server<span class="p">:</span><span class="w">    
</span><span class="w">    </span>use-read-only-response-cache<span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">    </span>response-cache-auto-expiration-in-seconds<span class="p">:</span><span class="w"> </span><span class="m">180</span><span class="w"> </span><span class="c"># readWriteCache 180s 过期</span><span class="w">
</span><span class="w">    </span>response-cache-update-interval-ms<span class="p">:</span><span class="w"> </span><span class="m">30000</span><span class="w"> </span><span class="c"># 30s readOnlyCache 30s 同步</span><span class="w">
</span><span class="w">    </span>initial-capacity-of-response-cache<span class="p">:</span><span class="w"> </span><span class="m">1000</span><span class="w"> </span><span class="c"># readWriteCache 容量</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="deltaretentiontimer">DeltaRetentionTimer</h3>
<p>Eureka client 向 server 获取实例列表时，一般会使用增量获取而非全量，这样做可以减少传输数据量、并降低响应时间。</p>
<p>com.netflix.eureka.registry.AbstractInstanceRegistry 使用 recentlyChangedQueue（ConcurrentLinkedQueue<RecentlyChangedItem>) 保存了最近变更的应用信息，支持 EurekaClient 获取增量注册信息。</p>
<p>注：delta 层注册、续租、下线等状态与核心 Map 存储同步更新，不存在滞后性。</p>
<p>默认情况下，定时任务每 30s 执行一次，超过 180s 未更新的实例将被清理，可通过 <code>eureka.server.retention-time-in-m-s-in-delta-queue</code> 控制保存时长。</p>
<p>如果 <code>eureka.server.disable-delta=true</code>，定时任务仍旧照常执行，只不过，Eureka server 在接到  get delta 请求时，会把它重定向到 get all。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 任务随 AbstractInstanceRegistry 构造函数启动调度
</span><span class="c1"></span><span class="k">this</span><span class="o">.</span><span class="na">deltaRetentionTimer</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="n">getDeltaRetentionTask</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">serverConfig</span><span class="o">.</span><span class="na">getDeltaRetentionTimerIntervalInMs</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">serverConfig</span><span class="o">.</span><span class="na">getDeltaRetentionTimerIntervalInMs</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="c1">// timer task
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">RecentlyChangedItem</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">recentlyChangedQueue</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getLastUpdateTime</span><span class="o">(</span><span class="o">)</span> <span class="o">&lt;</span>
              <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span> <span class="n">serverConfig</span><span class="o">.</span><span class="na">getRetentionTimeInMSInDeltaQueue</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">it</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>相关配置如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>server<span class="p">:</span><span class="w">
</span><span class="w">    </span>disable-delta<span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="w">    </span><span class="c"># 废弃功能配置，早期实现会在本地获取不到 delta 时，会向所有远程实例获取 delta</span><span class="w">
</span><span class="w">    </span><span class="c"># 现在 Eureka server 会客户端声明远程 Region 列表决定是否向远程实例获取 delta</span><span class="w">
</span><span class="w">    </span><span class="c"># disable-delta-for-remote-regions: false </span><span class="w">
</span><span class="w">    </span>delta-retention-timer-interval-in-ms<span class="p">:</span><span class="w"> </span><span class="m">30000</span><span class="w"> </span><span class="c"># 定时任务每 30s 执行一次</span><span class="w">
</span><span class="w">    </span>retention-time-in-m-s-in-delta-queue<span class="p">:</span><span class="w"> </span><span class="m">180000</span><span class="w"> </span><span class="c"># 清理超过 3 分钟未更新的实例</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="taskacceptor--taskbatchingworker">TaskAcceptor &amp; TaskBatchingWorker</h3>
<p>Eureka server 针对每个集群节点(Peer Node)，都会启动 1 组线程批量处理集群实例信息同步，同步范围包括实例 register、cancel、heartbeat、statusUpdate 和 deleteStatusOverride，这部分逻辑集中在 com.netflix.eureka.cluster.PeerEurekaNode。</p>
<p>线程组包含 1 个 Acceptor 线程加上若干 Worker 线程（默认 20，通过 <code>eureka.server.max-threads-for-peer-replication</code> 设置）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>server<span class="p">:</span><span class="w">
</span><span class="w">    </span>max-elements-in-peer-replication-pool<span class="p">:</span><span class="w"> </span><span class="m">10000</span><span class="w"> </span><span class="c"># pending task queue 最大容量</span><span class="w">
</span><span class="w">    </span>max-threads-for-peer-replication<span class="p">:</span><span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="c"># batch 线程数量</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Acceptor 在设计上使用了 3 级队列，第 1 级包括了最新的实例变更信息，没有显式设置容量限制。</p>
<ul>
<li>Eureka server PeerAwareInstanceRegistry 实现在接到客户端请求后，先写本地 registry，随之将变更提交到 Acceptor 对象的 accept queue (通过 PeerEurekaNode 实现），请求即立刻返回客户端，实际同步采用批处理方式完成。</li>
<li>Acceptor daemon 线程不断尝试从 accept queue 获取任务并转至第 2 级的 pending task queue（实现上是 LinkedList + HashMap），pending task queue 容量默认 10,000，由 <code>eureka.server.max-elements-in-peer-replication-pool</code> 设置，超过容量后，使用 FIFO 方式丢弃任务。</li>
<li>同时，每当 pending queue 任务数量到达容量阈值 (10,000)，或者每隔 500ms，Acceptor daemon 线程会将任务成批打包成 List（容量上限 250，写死无法配置），放置到 3 级队列 batch work queue 中。所有 Worker 线程共享该 3 级队列， JDK BlockQueue 为线程安全实现。Worker 线程不断尝试从 batch work queue  获取到 batch List 后，使用封装好的 HTTP Transport 实现将状态传递给集群其他节点。</li>
</ul>
<img src="/img/2020-04/eureka-batch-replica-internal.jpg" width="500px">
<p>每个 Peer Node 使用 20 线程处理信息同步，对于小集群来说可能比较浪费，可根据实际情况调整线程数量。</p>
<h3 id="taskacceptor--tasknonbatchingworker">TaskAcceptor &amp; TaskNonBatchingWorker</h3>
<p>TaskNonBatchingWorker 其实就是 TaskBatchingWorker batch size 为 1 的特殊情况，netflix 专门用于处理 AWS Autoscaling group(ASG）变更同步，不使用 ASG 就用不到。</p>
<p>其对应配置如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>server<span class="p">:</span><span class="w">
</span><span class="w">    </span>max-threads-for-status-replication<span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c"># batch 线程数量</span><span class="w">
</span><span class="w">    </span>max-elements-in-status-replication-pool<span class="p">:</span><span class="w"> </span><span class="m">10000</span><span class="w"> </span><span class="c"># pending task queue 最大容量</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="evict-">Evict 任务</h3>
<ol>
<li>主任务 EvictionTimer</li>
</ol>
<hr>
<p>对于未能在租期（默认 90s）通过心跳请求续租的实例，Eureka 使用定时任务，执行清理工作，实现在 com.netflix.eureka.registry。AbstractInstanceRegistry$EvictionTask。</p>
<p>租期淘汰任务执行频率由 <code>eureka.server.eviction-interval-timer-in-ms</code> 控制，默认 60s 一次。</p>
<p>Eureka 实现了名为「自我保护」的功能，用来检测网络分裂（<a href="https://en.wikipedia.org/wiki/Network_partition">network partition</a>)这类问题。如果关闭了自我保护，直接执行清理；如果开启了自我保护，会使用结合辅助任务 RenewalThresholdUpdater 和 MeasureRateTimer → renewsLastMin 判断是否停止清理注册实例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>sever<span class="p">:</span><span class="w">
</span><span class="w">    </span>eviction-interval-timer-in-ms<span class="p">:</span><span class="w"> </span><span class="m">60000</span><span class="w"> </span><span class="c"># 默认 60s 一次</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>辅助任务 RenewalThresholdUpdater</li>
</ol>
<hr>
<p>用来更新自我保护开启阈值，实现见 com.netflix.eureka.registry.ReplicaAwareInstanceRegistry。</p>
<p>自我保护开启时(<code>enable-self-preservation=true</code>)，默认每 15 分钟更新一次续约刷新阈值，如果 eureka 每分钟收到的心跳数量小于阈值 <strong>注册instances数量x2x0.85</strong>，便会开启自我保护，不再淘汰实例。</p>
<p>相关配置如下，值得注意的是，即使关闭自我保护，该任务仍旧会定时执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>server<span class="p">:</span><span class="w">
</span><span class="w">     </span>enable-self-preservation<span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 是否开启自我保护</span><span class="w">
</span><span class="w">     </span>renewal-percent-threshold<span class="p">:</span><span class="w"> </span><span class="m">0.85</span><span class="w"> </span><span class="c"># renew-interval 注册实例预期心跳比例</span><span class="w">
</span><span class="w">     </span>expected-client-renewal-interval-seconds<span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w"> </span><span class="c"># 实例心跳间隔</span><span class="w">
</span><span class="w">     </span>renewal-threshold-update-interval-ms<span class="p">:</span><span class="w"> </span><span class="m">900000</span><span class="w"> </span><span class="c"># 15 分钟</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>辅助任务 MeasureRateTimer → renewsLastMin</li>
</ol>
<hr>
<p>默认记录并定期更新当前 60s 和上一 60s 注册实例的续租次数，见 com.netflix.eureka.registry.AbstractInstanceRegistry 属性 renewsLastMin，使用实现类 MeasuredRate 存储注册实例租约刷新次数，每 60s 更新上一分钟的租约刷新次数，供 Registry 实现判断是否需开启自我保护之用。</p>
<h3 id="peernodesupdater">PeerNodesUpdater</h3>
<p>实现见 com.netflix.eureka.cluster.PeerEurekaNodes#start。</p>
<p>作用是动态更新 Peer 节点列表，当配置 <code>eureka.client.serviceUrl</code> 和 <code>eureka.client.availability-zones</code> 发生变化时，动态更新通信集群节点，对应配置如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>server<span class="p">:</span><span class="w">
</span><span class="w">    </span>peer-eureka-nodes-update-interval-ms<span class="p">:</span><span class="w"> </span><span class="m">600000</span><span class="w"> </span><span class="c"># 10*60*1000，默认 10 分钟执行一次，启动延迟 10 分钟</span><span class="w">
</span><span class="w"></span>eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>client<span class="p">:</span><span class="w">
</span><span class="w">    </span>serviceUrl<span class="p">:</span><span class="w"> 
</span><span class="w">      </span>defaultZone<span class="p">:</span><span class="w"> </span>http<span class="p">:</span>//peer1<span class="p">:</span><span class="m">8761</span>/eureka/<span class="p">,</span>http<span class="p">:</span>//peer2<span class="p">:</span><span class="m">8762</span>/eureka/<span class="w">
</span><span class="w">  </span>availability-zones<span class="p">:</span><span class="w">
</span><span class="w">    </span>shanghai<span class="p">:</span><span class="w"> </span>defaultZone<span class="w">
</span><span class="w">  </span>region<span class="p">:</span><span class="w"> </span>shanghai<span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="measureratetimer--numberofreplicationslastmin">MeasureRateTimer → numberOfReplicationsLastMin</h3>
<p>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl  定时任务，属性 numberOfReplicationsLastMin。
使用实现类 MeasuredRate 存储 peer 节点同步实例数量，每 60s 更新上一分钟的同步次数，供监控使用。</p>
<h2 id="client">Client</h2>
<p>以下线程任务处理客户端缓存更新</p>
<ul>
<li>DiscoveryClient-0</li>
<li>DiscoveryClient-CacheRefreshExecutor-0</li>
</ul>
<p>以下线程任务处理实例续租</p>
<ul>
<li>DiscoveryClient-1</li>
<li>DiscoveryClient-HeartbeatExecutor-0</li>
</ul>
<p>DiscoveryClient-InstanceInfoReplicator-0 处理服务状态更新，AsyncResolver-bootstrap-0 处理 Eureka Server 节点更新。</p>
<p>Eureka Client 在处理缓存定时更新和定时心跳续租时，采用双级线程池模式，里层线程池定时执行业务逻辑，外层线程池处理超时（超时时间等于执行间隔，实现见 com.netflix.discovery.TimedSupervisorTask)，所以各需要 2 个线程。如果频繁超时导致任务积压，可能会启动临时业务线程 DiscoveryClient-CacheRefreshExecutor-1 和 DiscoveryClient-HeartbeatExecutor-1。</p>
<p>Eureka client 核心类为 <strong>com.netflix.discovery.DiscoveryClient</strong>，它在构造时会根据配置启动一系列定时任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml">eureka<span class="p">:</span><span class="w">
</span><span class="w">  </span>client<span class="p">:</span><span class="w">
</span><span class="w">    </span>registerWithEureka<span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 是否注册到 Eureka server</span><span class="w">
</span><span class="w">    </span>fetchRegistry<span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># 是否向 Eureka server 获取注册实例</span><span class="w">
</span><span class="w">    </span>heartbeat-executor-thread-pool-size<span class="p">:</span><span class="w"> </span><span class="m">2</span><span class="w">
</span><span class="w">    </span>cache-refresh-executor-thread-pool-size<span class="p">:</span><span class="w"> </span><span class="m">2</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="cacherefresh">CacheRefresh</h3>
<p>集群应用列表获取任务，，一般由 scheduler DiscoveryClient-0 线程管理，由 DiscoveryClient-CacheRefreshExecutor-0 或 DiscoveryClient-CacheRefreshExecutor-1 执行，默认 30s 一次。</p>
<p>当 <code>eureka.client.registerWithEureka=false</code> 时，不会启动该任务。</p>
<p>可以通过 <code>eureka.client.registry-fetch-interval-seconds</code> 设置执行频率，默认 30s 一次。</p>
<h3 id="heartbeat">heartbeat</h3>
<p>心跳续租任务，一般由 scheduler DiscoveryClient-1 线程管理，由 DiscoveryClient-HeartbeatExecutor-0 或 DiscoveryClient-HeartbeatExecutor-1 执行，默认 30s 一次。</p>
<p>当 <code>eureka.client.registerWithEureka=false</code> 时，不会启动该任务。</p>
<p>可以通过 <code>eureka.instance.lease-expiration-duration-in-seconds</code> 调整租期，默认 90s。</p>
<p>可以通过 <code>eureka.instance.lease-renewal-interval-in-seconds</code> 调整心跳频率，默认 30s/次。</p>
<h3 id="instanceinforeplicator">InstanceInfoReplicator</h3>
<p>处理实例状态变更（通过  ApplicationInfoManager#setInstanceStatus），如从 UP 变为其状态 {DOWN，STARTING，OUT_OF_SERVICE，UNKNOWN}，ApplicationInfoManager 的StatusChangeListener 会向 InstanceInfoReplicator 提交变更任务。</p>
<p>也就是说，实例状态变更和 heartbeat 续租分属不同逻辑分支。</p>
<p>InstanceInfoReplicator 经过一些 RateLimiter 策略判断后，会调用 DiscoveryClient#register 向 Eureka 重新注册应用状态。</p>
<p>主要用于实例上下线</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">setInstanceStatus</span><span class="o">(</span><span class="n">InstanceStatus</span> <span class="n">status</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">InstanceStatus</span> <span class="n">next</span> <span class="o">=</span> <span class="n">instanceStatusMapper</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">status</span><span class="o">)</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">InstanceStatus</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">instanceInfo</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="n">next</span><span class="o">)</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">StatusChangeListener</span> <span class="n">listener</span> <span class="o">:</span> <span class="n">listeners</span><span class="o">.</span><span class="na">values</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">listener</span><span class="o">.</span><span class="na">notify</span><span class="o">(</span><span class="k">new</span> <span class="n">StatusChangeEvent</span><span class="o">(</span><span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&#34;failed to notify listener: {}&#34;</span><span class="o">,</span> <span class="n">listener</span><span class="o">.</span><span class="na">getId</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">statusChangeListener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ApplicationInfoManager</span><span class="o">.</span><span class="na">StatusChangeListener</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getId</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;statusChangeListener&#34;</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">notify</span><span class="o">(</span><span class="n">StatusChangeEvent</span> <span class="n">statusChangeEvent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">InstanceStatus</span><span class="o">.</span><span class="na">DOWN</span> <span class="o">=</span><span class="o">=</span> <span class="n">statusChangeEvent</span><span class="o">.</span><span class="na">getStatus</span><span class="o">(</span><span class="o">)</span> <span class="o">|</span><span class="o">|</span>
                <span class="n">InstanceStatus</span><span class="o">.</span><span class="na">DOWN</span> <span class="o">=</span><span class="o">=</span> <span class="n">statusChangeEvent</span><span class="o">.</span><span class="na">getPreviousStatus</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// log at warn level if DOWN was involved
</span><span class="c1"></span>            <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&#34;Saw local status change event {}&#34;</span><span class="o">,</span> <span class="n">statusChangeEvent</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Saw local status change event {}&#34;</span><span class="o">,</span> <span class="n">statusChangeEvent</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">instanceInfoReplicator</span><span class="o">.</span><span class="na">onDemandUpdate</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="asyncresolverbootstrap0">AsyncResolver-bootstrap-0</h3>
<p>逻辑入口 scheduleServerEndpointTask#scheduleServerEndpointTask</p>
<p>任务位置 AsyncResolver#updateTask</p>
<p>Client 端 Eureka Service 列表定时更新任务，不断读取内存配置并尝试更新 Eureka Service 列表，默认 5 分钟执行一次，无法禁止，可以使用 <code>eureka-service-url-poll-interval-seconds</code> (默认 300s) 控制执行间隔。</p>
<h2 id="transport">Transport</h2>
<p>Eureka Server 或 Eureka Client 部分均使用 JerseyClient HTTP Transport 抽象（实现为 Apache HttpClient）处理实例信息复制或实例信息注册，每个 Eureka 相关实例（包括自己）均对应一个独立的 Transport Client。</p>
<p>对每个 Transport Client，Eureka 均会启动 Eureka-JerseyClient-Conn-Cleaner 线程清理空闲 HTTP 连接，任务位置 com.netflix.discovery.shared.transport.jersey.ApacheHttpClientConnectionCleaner#cleanIdle(long  delayMs)。</p>
<p>定时任务每 30s 执行一次，无法修改频率，无法被关闭。默认情况下，超过 30s 未活动连接将被关闭。可以通过 <code>eureka.client.eureka-connection-idle-timeout-seconds</code> 调整闲置时间阈值。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Zeng Xu</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-05-08 00:22
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content">本作品采用 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接。</span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/spring-cloud/">Spring Cloud</a>
          <a href="/tags/eureka/">Eureka</a>
          <a href="/tags/spring/">Spring</a>
          <a href="/tags/java/">Java</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/20200428-eureka-multil-cluster-replica/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">如何迁移 Spring Cloud Eureka 注册体系至 k8s</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/20200415-containerd-image-import/">
            <span class="next-text nav-default">containerd 手动导入镜像</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2020-04-25 20:40:29 \x2b0800 CST',
        title: '从定时任务分析 Eureka 架构设计',
        clientID: '6ab3c721bb197ea92f1e',
        clientSecret: '217d38cc1905f60f1d963c555be606ed3e707937',
        repo: 'phosae.github.io',
        owner: 'phosae',
        admin: ['phosae'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zenngxu@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/phosae" class="iconfont icon-github" title="github"></a>
  <a href="https://www.zeng.dev/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Zeng Xu</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-149382924-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
